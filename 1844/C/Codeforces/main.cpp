//
//  main.cpp
//  Codeforces
//
//  Created by loyinglin.
//  Copyright loyinglin. All rights reserved.

/************************** 题解 **********************
 [题目链接](https://codeforces.com/contest/1844/problem/C)
 **题目大意：**
 有n个整数的数组，现在可以对数组进行操作：
 1、选择某个位置的元素；
 2、移除该元素；
 3、如果该元素原来左右两边均有数字，那么这两个数字也会移除，合并成一个新的数字；（如果左右两边只有1个数字，则不会触发合并）
 如下图所示：
 ![如图](https://espresso.codeforces.com/e03b7cd1557bc6141aa5ceb08d033c7fb1f3d7a9.png)
 
 现在想知道，经过若干次操作后，数组剩下一个元素时，这个元素最大值为多少？
 
 **输入：**
 第一行，整数𝑡 表示t个样例 𝑡 (1≤𝑡≤10000)
 每个样例第一行整数𝑛 (1≤𝑛≤20000).
 接下来n个整数 𝑐1,…,𝑐𝑛(−1e9≤𝑐𝑖≤1e9).
 
 **输出：**
 每个样例一行，输出结果的最大值。
 
 **Examples**
 **input**
 3
 6
 -3 1 4 -1 5 -9
 5
 998244353 998244353 998244353 998244353 998244353
 1
 -2718



 **output**
 9
 2994733059
 -2718



 **题目解析：**
 这个题目最终实现不复杂，但是在分析过程踩了一下坑，这里特意做一个记录，简单回顾下出问题点。
 
 最开始的思路：
 简化题目，只考虑有正数的情况，是否有简单的策略：
 每次会发生可能两个行为，数字移除+数字合并，数字移除会减少一个数字并影响最终的和，数字合并不会直接影响最终的和，但是仍然会对结果有影响，因为我们减少了一个可移除的数字选择；
 比如说【10，5，1，5，10】这样的数组，当我们先选择1时，剩下【10， 10，10】，最终结果是20；如果只选择移除整数5，那么最终结果是21；
 那么就不能采用简单的从最小开始移除的合并策略（尤其此时还没引入负数）。
 观察区间的特性，我们知道对于每一个新增的数字，有两个选择：
 1、直接移除，此时在最右边，原来区间不会发生任何事情；
 2、原区间右边最右整数被移除，当前数字被进行合并；
 根据两个选择可以得到对应的状态转移方案。
 
 到这里整体思路还算清晰，但是出现一个问题，当进行决策1之后，该位置的数字必须全部摒弃。
 那么每个位置应该有两个状态：
 1、当前数字是被移除；（dp[i][0])
 2、当前数字是保留的状态；(dp[i][1])
 dp[i][0]可以由dp[i-1][1]转移，dp[i][1]可以由dp[i-1][0]转移，转移方程：
 dp[i][0] = dp[i-1][1];
 dp[i][1] = max(0LL, dp[i-1][0]) + a[i];

 看着一切美好，但是在遇到下面这串样例的时候，问题就出现了：
 5 -1 -2 -3 6
 
 这里动态规划会出问题，因为当a[i]=6时，我们选择保留元素6，那么就会remove -3，结果就是-2和6合并了。
 我们知道最优解是先选择数字-2，生成5 -4 6；再选择-4，得到结果11；
 因为这里的决策无后效性并不满足。
 
 舍弃动态规划，从题目的操作特性来分析，对于相邻的两个数字，必然不能融合。
 奇数位置的数字，只能和奇数位置融合；
 偶数位置的数字，只能和偶数位置融合；
 
 那么是否可以做到任意奇数位置的整数都能融合？
 首先，连续的奇数位置必然是可以融合，因为只间隔着1个数字，选择remove该整数即可；
 对于不间断的奇数位置，我们只需考虑间隔1、2个整数的情况皆可，其他间隔情况都可以由这2个情况来推出。
 间隔1个整数的情况，比如说 [1,-2,-2,-2,1]，奇数位置整数是[1,-2,1]，我们可以选择第一次remove最中间的-2，得到[1, -4, 1]，再选择中间的整数-4，即可得到2；
 间隔2个整数的情况，比如说 [1,-2,-2,-3,-3,-1,1]，同样的操作，我们一直选择remove最中间的整数，由于每次我们remove1个整数，融合减少1个整数，最终一定会剩下[1, x, 1]这样的结果，也即是必然可以融合得到2；
 
 那么这个题目就比较简单了，只需要考虑奇数位置、偶数位置上选择若干个整数，得到的最小和。

 
 ************************* 题解 ***********************/
#include<cstdio>
#include<cmath>
#include<stack>
#include<map>
#include<set>
#include<queue>
#include<deque>
#include<string>
#include<utility>
#include<sstream>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
 
typedef long long lld;
 
class Solution {
    static const int N = 201010;
    lld dp[N][2], a[N];
public:
    void solve() {
        int t;
        cin >> t;
        while (t--) {
            int n;
            cin >> n;
            for (int i = 0; i < n; ++i) {
                cin >> a[i];
//                if (i == 0) dp[0][1] = a[i];
//                if (i == 1) {
//                    dp[1][0] = dp[0][1];
//                    dp[1][1] = a[1];
//                }
//                if (i >= 2) {
//                    dp[i][0] = dp[i-1][1];
//                    dp[i][1] = max(0LL, dp[i-1][0]) + a[i];
//                }
//                ans = max(ans, dp[i][1]);
//                cout << i << " " << dp[i][0] << " " << dp[i][1] << endl;
            }
            if (n == 1) cout << a[0] << endl;
            else {
                lld ans[2] = {a[0], a[1]};
                for (int i = 2; i < n; ++i) {
                    if (a[i] < 0) ans[i%2] = max(ans[i%2], a[i]);
                    else {
                        ans[i%2] = max(a[i], ans[i%2] + a[i]);
                    }
                }
                cout << max(ans[0], ans[1]) << endl;
                
            }
            
        }
    }
}
ac;
 
int main(int argc, const char * argv[]) {
    // insert code here...
    
    ac.solve();
    
    return 0;
}
 
