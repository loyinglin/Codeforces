//
//  main.cpp
//  Codeforces
//
//  Created by loyinglin.
//  Copyright loyinglin. All rights reserved.

/************************** 题解 **********************
 [题目链接](https://codeforces.com/contest/2118/problem/B)
使其成为排列

有一个大小为n×n的矩阵A，初始状态对于所有1 ≤ i, j ≤ n，都有A[i][j] = j 。
现在可以执行多个操作，每次操作中，你可以选择一行，并反转该行中的一个选定的子数组。
子数组的定义：数组a是数组b的子数组，当且仅当a可以通过从b的开头删除零个或多个元素，以及从结尾删除零个或多个元素得到。

现在最多可以执行2n次操作，要求操作后每一列都包含一个长度为n的排列。
排列的定义：长度为n的排列是由n个从1到n的不同整数按任意顺序组成的数组。例如，[2, 3, 1, 5, 4]是一个排列，但[1, 2, 2]不是排列，因为2出现了两次；[1, 3, 4]也不是排列，因为n=3，但数组中出现了4。

可以证明这样的构造总是可行的。如果有多个解，输出任意一个即可。

输入
每个测试用例包含多个测试案例。第一行包含测试案例的数量t（1 ≤ t ≤ 100）。接下来是各测试案例的描述。
每个测试案例的第一行包含一个整数n（3 ≤ n ≤ 5000 ），表示矩阵的行数和列数。
保证所有测试案例中n的总和不超过5000。

输出
对于每个测试案例，在第一行打印一个整数k（0 ≤ k ≤ 2n ），即你希望执行的操作次数。接下来的行中，打印具体的操作。
要打印一个操作，使用格式“i l r”（1 ≤ l ≤ r ≤ n 且 1 ≤ i ≤ n ），表示反转行i中从第l个元素到第r个元素的子数组。

示例
输入
2
3
4

输出
4
1 1 3
2 2 3
3 2 3
3 1 3
5
1 1 4
3 1 4
2 1 4
3 1 4
4 1 4

 
**题目解析：**
这个题目也是典型的构造题，这类题目没有固定的解法，但是从经验上来讲，从小处开始模拟分析，总是能找到规律。

首先考虑n=2的情况
12
12
此时只有一种选择【2，1，2】，也就是反转第二行的1到2个元素，得到结果：
12
21

当n=3的情况
123
123
123
从第二行开始，我们发现第一列缺乏数字2，那么用操作【2，1，2】，可以得到结果：
123
213
123

从第三行开始，我们发现第一列缺乏数字3，那么用操作【3，1，3】，可以得到结果：
123
213
321
此时第一列已经满足了排列123的要求；
再看第二列，发现差一个数字3，此时可以选择【1，2，3】操作，可以得到结果：
132
213
321
第二列已经满足了123排列的要求，并且第三列也满足了。

同样的操作方式处理n=4的情况，可以得到最终结果
1432
2143
3214
4321

1432
2143
3214
4321

n=5的情况
15432
21543
32154
43215
54321

15432
21543
32154
43215
54321

此时我们基本可以摸清楚这样的一个规律，
我们先对第1列进行操作，此时需要操作n-1次；
再对第2列进行操作，此时需要操作1次，并且行数是1；
再对第3列进行操作，此时需要操作1次，并且行数是2；
...
再对第n-1列进行操作，此时需要操作1次，并且行数是n-2；
总的操作次数是n-1+(n-2)=2n-3，符合题目要求。
 
 ************************* 题解 ***********************/
#include<cstdio>
#include<cmath>
#include<stack>
#include<map>
#include<set>
#include<queue>
#include<deque>
#include<string>
#include<utility>
#include<sstream>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
 
typedef long long lld;
 
class Solution {
    static const int N = 201010;

public:
    void solve() {
        int t;
        cin >> t;
        
        while (t--) {
            int n;
            cin >> n;
            cout << (n == 1 ? 0 : (2 * n - 3)) << endl;
            for (int i = 2; i <= n; ++i) {
                cout << i << " " << 1 << " " << i << endl;
            }
            for (int i = 1; i < n - 1; ++i) {
                cout << i << " " << i + 1 << " " << n << endl;
            }
        }
    }
}
ac;
 
int main(int argc, const char * argv[]) {
    // insert code here..
    ac.solve();
    return 0;
}
 
