//
//  main.cpp
//  Codeforces
//
//  Created by loyinglin.
//  Copyright loyinglin. All rights reserved.

/************************** 题解 **********************
 [题目链接](https://codeforces.com/contest/2118/problem/C)
使其美丽 

给定一个由n个整数组成的数组a。我们将一个数x的“美丽值”定义为其二进制表示中1的个数。数组的“美丽值”定义为数组中所有数的美丽值之和。 
在一次操作中，你可以选择一个下标i（1 ≤ i ≤ n）并将aᵢ的值加1。 
在最多进行k次操作后，找出数组能达到的最大美丽值。 

输入 
每个测试用例包含多个测试案例。第一行包含测试案例的数量t（1 ≤ t ≤ 5000）。接下来是各测试案例的描述。 
每个测试案例的第一行包含两个整数n和k（1 ≤ n ≤ 5000，0 ≤ k ≤ 10¹⁸），分别表示数组的长度和最多可进行的操作次数。 
每个测试案例的第二行包含n个整数a₁, a₂, …, aₙ（0 ≤ aᵢ ≤ 10⁹），表示数组a。 
保证所有测试案例中n的总和不超过5000。 

输出 
对于每个测试案例，输出一个整数，即最多进行k次操作后能达到的最大美丽值。 

示例 
输入 
5
5 2
0 1 7 2 4
5 3
0 1 7 2 4
1 1
3
3 0
2 0 3
1 100000000000
0


输出 
8
9
2
3
36


说明 
在第一个测试案例中，数组a初始为[0, 1, 7, 2, 4]。 
- 在下标i=1处进行第一次操作，新数组变为a = [1, 1, 7, 2, 4] 
- 在下标i=4处进行第二次操作，新数组变为a = [1, 1, 7, 3, 4] 
此时数组的美丽值为1 + 1 + 3 + 2 + 1 = 8。另一个能得到相同美丽值的有效方案得到的数组是[0, 1, 7, 3, 5]。 

在第三个测试案例中，数组a初始为[3]。由于不要求必须用完k次操作，所以最优选择是不进行任何操作。 

 
**题目解析：**
先考虑只有一个数字的情况，我们可以执行若干次操作，但是最终结果还是相当于把这个数中二进制数字为0的部分改为1；
举个例子，当考虑数字6时，二进制为110，我们可以选择操作将最右边的0为1；
当数字变成111这样的全一数字之后，接下来再操作就只能往前面添加数字1，也就是变成1111、11111；
过程中，我们只需要考虑剩余的k，是否足够在对应的操作。
是否足够的判断也简单，比如说110->111的代价就是两数相减111-110=1，1111-111=1000也就是2的3次方=8；
这样，我们就找到了一个数字情况的最优解。
当有多个数字情况，比如说110、1010呢？
我们可以把两个数字补0对齐，这样方便分析：
00110
01010
首先操作的还是最靠右且数字为0的位置，将其变为1；
到此，我们想到了一个简单的策略：
将所有数字二进制化，右对齐，左边补0；
然后每次从上到下，从右到左找数字为0的位置，将其变为1；
而代价就是对应位置为1，其他位置为0的数字的值。
时间复杂度，从上到下复杂度O（N），从右到左复杂度O（logK）；
 
 ************************* 题解 ***********************/
#include<cstdio>
#include<cmath>
#include<stack>
#include<map>
#include<set>
#include<queue>
#include<deque>
#include<string>
#include<utility>
#include<sstream>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
 
typedef long long lld;
 
class Solution {
    static const int N = 11010;
    lld a[N];
public:
    void solve() {
        int t;
        cin >> t;

        while (t--) {
            lld n, k;
            cin >> n >> k;
            for (int i = 0; i < n; ++i)  {
                cin >> a[i];
            }
            lld ans = 0;
            for (int j = 0; j < 63; ++j) {
                for (int i = 0; i < n; ++i) {
                    if (a[i] & (1ll << j)) {
                        ++ans;
                    }
                    else {
                        if (k >= (1ll << j)) {
                            ++ans;
                            k -= (1ll << j);
                        }
                    }
                }
            }
            cout << ans << endl;
        }
    }
}
ac;
 
int main(int argc, const char * argv[]) {
    // insert code here..
    ac.solve();
    return 0;
}
 
