//
//  main.cpp
//  Codeforces
//
//  Created by loyinglin.
//  Copyright loyinglin. All rights reserved.

/************************** 题解 **********************
 [题目链接](https://codeforces.com/contest/1904/problem/D1)
 **题目大意：**
 给出n个整数的数组a和b，现在可以对数组a进行操作：
 选择数组内任意区间[l, r]，将区间[l, r]内的整数都改为区间的最大值。
 比如，对于数组[1, 2, 3, 4, 5]，选择区间[1, 3]进行操作，则会生成[3, 3, 3, 4, 5]；
 
 现在想知道，数组a是否可以进行若干次上面的操作，最终变成数组b。
 
 
 **输入：**
 第一行，整数𝑡 表示t个样例 𝑡 (1≤𝑡≤10000)
 每个样例3行
 第1行整数 n  (1≤n≤1000)
 第2行整数 𝑎1,𝑎2,…,𝑎𝑛 (1≤𝑎𝑖≤𝑛)
 第3行整数 𝑏1,𝑏2,…,𝑏𝑛 (1≤𝑏𝑖≤𝑛)
  
 **输出：**
 每个样例一行，如果可行则输出YES，如果不可行则输出NO；
 
 
 **Examples**
 **input**
 5
 5
 1 2 3 2 4
 1 3 3 2 4
 5
 3 4 2 2 4
 3 4 3 4 4
 5
 3 2 1 1 1
 3 3 3 2 2
 2
 1 1
 1 2
 3
 1 1 2
 2 1 2



 **output**
 YES
 NO
 YES
 NO
 NO



 **题目解析：**
 从数据量较小的情况开始分析，比如说n=2时，数组数字可以简化成1和2；
 那么就会有[1,2]和[2,2]，比较容易得到结果；
 当n=3时，我们增加个数组3，如果放在数组[1,2]左右两边，对结果不影响；但是如果放在中间，数组[1, 3, 2]是无法变成[2, 3, 2]；
 由此我们可以知道，较大的数字会阻断较小的数字传递；
 当n=4时，我们可以看到一个有意思的样例：
 1,2,3,4
 3,4,4,4
 数字3，跨过第2个数字影响到了第1个数字，然后第2、3个数字最终又被数字4覆盖。
 由此我们可以知道，数字的影响是最终可能非间隔，但是必须传递过去，并且中间路径可能被更大数字覆盖。
 
 至此，我们的思路就清晰起来：
 1、从小到大来枚举数字，因为当x覆盖过某个数字后，只有x+1才能覆盖这个覆盖；
 2、每一个数字，都可以向左右蔓延，蔓延条件有两个，隔壁数字小于等于当前数字，隔壁数字对应的数组b元素要大于等于当前数字；
 3、重复上面所有的过程，直到所有数字结束；
 
 这里的核心依据，就是通过数组b的元素作为数组a元素的上限，尽可能让每一个数组a元素去变大。
 
 
 思考：
 当N的范围再扩大1000倍呢？上面的这个做法在效率上就会不足，但是思路可以沿用扩展。
 首先回顾这里的耗时操作，首先是枚举数字从小到大，然后找到和这个位置对应的数字，简单实现是O（N^2）的复杂度，但是我们先预处理一遍数组，记录每个数字对应的下标，这样就可以做到O（N）的复杂度；
 其次是在数字覆盖的过程中，有时会出现每个位置被重复覆盖多次的情况，但是对于结果而言，我们只需要知道某个位置不匹配时（a[i] != b[i]），它应该往数组a左边/右边去找到等于b[i]的元素。
 这个过程，同样可以预处理。
 比如说对于下面的样例，当a[3] != b[3]，我们要往数组a两边去找数组元素等于3的情况；
 3 3 2 1 4 3 3
 3 3 3 3 4 3 3
 首先在前面的预处理步骤，我们记录每一个数字的位置，那么对于数字3，我们同样记录了3在数组a的位置为[0,1,5,6]，这样我们很容易知道对于a[3]而言，最近数字3位置在a[1]和a[5]；
 
 接下来的问题是，对于某个位置i和某个位置j，是否能够匹配？
 还是用上面的样例，我们才用采样这样的策略：
 1、对于数组a，我们从小到大枚举的元素的过程，我们把枚举过的数字（包括当前数字），在数组a出现的位置都用1来标明；（某个位置为1，表示该位置可以延伸）
 2、对于数组b，我们从小到大枚举的元素的过程，我们把还没有枚举过的数字（包括当前数字），在数组b出现的位置都用1来标明；（某个位置为1，表示该位置可以延伸）
 样例数据
 3 3 2 1 4 3 3
 3 3 3 3 4 3 3
 就可以转义为
 1 1 1 1 0 1 1
 1 1 1 1 1 1 1
 这样， 当我们在判断a[1]和a[3]是否能够匹配时，其实就是判断数组a区间[1, 3]的数字和是否为3，并且数组b区间[1,3]的数字和是否为3；
 
 那么如何做快速的标记、以及计算累加和呢？
 1、标记问题，通过预处理我们能O(1)获取对应位置，并且每个数字我们只会标记一次，所以总的标记复杂度是O(N)；
 2、计算累加和，在一个数组里面，可以对某些元素进行数值修改、然后要求区间和，可以用线段树来解决。
 
 ************************* 题解 ***********************/
#include<cstdio>
#include<cmath>
#include<stack>
#include<map>
#include<set>
#include<queue>
#include<deque>
#include<string>
#include<utility>
#include<sstream>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
 
typedef long long lld;
 
class Solution {
    static const int N = 201010;
    int a[N], b[N];
public:
    void solve() {
        int t;
        cin >> t;
        while (t--) {
            int n;
            cin >> n;
            for (int i = 0; i < n; ++i) cin >> a[i];
            for (int i = 0; i < n; ++i) cin >> b[i];
            for (int k = 1; k <= n; ++k) {
                for (int i = 0; i < n; ++i) {
                    if (a[i] == k) {
                        int x = i - 1, y = i + 1;
                        while (x >= 0 && a[x] <= k && k <= b[x]) {
                            a[x] = k;
                            --x;
                        }
                        while (y < n && a[y] <= k && k <= b[y]) {
                            a[y] = k;
                            ++y;
                        }
                    }
                }
            }
            int ans = 1;
            for (int i = 0; i < n; ++i) ans = ans && (a[i] == b[i]);
            cout << (ans ? "YES" : "NO") << endl;
        }
    }
}
ac;
 
int main(int argc, const char * argv[]) {
    // insert code here...
    
    ac.solve();
    
    return 0;
}
 
